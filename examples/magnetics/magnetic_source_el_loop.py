r"""
2. Magnetic source using an el. loop
====================================

Computing the :math:`E` and :math:`H` fields generated by a magnetic source

We know that we can get the magnetic fields from the electric fields using
Faraday's law, see :ref:`sphx_glr_gallery_magnetics_magnetic_field.py`.

However, what about computing the fields generated by a magnetic source?
There are two ways we can achieve that:

- **creating an electric loop source**, which is what we do in this example,
  or
- using the duality principle, see
  :ref:`sphx_glr_gallery_magnetics_magnetic_source_duality.py`.

We create a horizontal, electric loop source to generate a vertical magnetic
field in a homogeneous VTI fullspace, and compare it to the semi-analytical
solution of ``empymod``. (The code ``empymod`` is an open-source code which can
model CSEM responses for a layered medium including VTI electrical anisotropy,
see `emsig.github.io <https://emsig.github.io>`_.)

The method used here can be applied to an arbitrarily rotated, arbitrarily
shaped source loop.

"""
import emg3d
import empymod
import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate as sint
from matplotlib.colors import SymLogNorm
plt.style.use('ggplot')
# sphinx_gallery_thumbnail_path = '_static/thumbs/el-loop.png'


###############################################################################
def plot_data_rel(ax, name, data, x, vmin=-15., vmax=-7., mode="log"):
    """Plot function."""

    ax.set_title(name)
    ax.set_xlim(min(x)/1000, max(x)/1000)
    ax.set_ylim(min(x)/1000, max(x)/1000)
    ax.axis("equal")

    if isinstance(mode, str):
        if mode == "abs":
            cf = ax.pcolormesh(
                    x/1000, x/1000, np.log10(np.abs(data)), linewidth=0,
                    cmap="viridis", vmin=vmin, vmax=vmax, shading='nearest')
        else:
            cf = ax.pcolormesh(
                    x/1000, x/1000, data, linewidth=0, cmap="PuOr_r",
                    norm=SymLogNorm(linthresh=10**vmin,
                                    vmin=-10**vmax, vmax=10**vmax),
                    shading='nearest')
    else:
        cf = ax.pcolormesh(
                x/1000, x/1000, np.log10(data), vmin=vmin, vmax=vmax,
                linewidth=0,
                cmap=plt.cm.get_cmap("RdBu_r", 8), shading='nearest')

    return cf


###############################################################################
def plot_result_rel(depm, de3d, x, title, vmin=-15., vmax=-7., mode="log"):
    fig, axs = plt.subplots(figsize=(18, 10), nrows=2, ncols=3)

    if mode == "log":
        case = ""
    else:
        case = "|"

    # Plot Re(data)
    cf0 = plot_data_rel(axs[0, 0], r"(a) "+case+"Re(empymod)"+case,
                        depm.real, x, vmin, vmax, mode)
    plot_data_rel(axs[0, 1], r"(b) "+case+"Re(emg3d)"+case,
                  de3d.real, x, vmin, vmax, mode)
    cf2 = plot_data_rel(axs[0, 2], r"(c) Error real part",
                        np.abs((depm.real-de3d.real)/depm.real)*100, x,
                        vmin=-2, vmax=2, mode=True)

    # Plot Im(data)
    plot_data_rel(axs[1, 0], r"(d) "+case+"Im(empymod)"+case,
                  depm.imag, x, vmin, vmax, mode)
    plot_data_rel(axs[1, 1], r"(e) "+case+"Im(emg3d)"+case,
                  de3d.imag, x, vmin, vmax, mode)
    plot_data_rel(axs[1, 2], r"(f) Error imaginary part",
                  np.abs((depm.imag-de3d.imag)/depm.imag)*100,
                  x, vmin=-2, vmax=2, mode=True)

    # Colorbars
    fig.colorbar(cf0, ax=axs[0, :], label=r"$\log_{10}$ Amplitude (A/m)")
    cbar = fig.colorbar(cf2, ax=axs[1, :], label=r"Relative Error")
    cbar.set_ticks([-2, -1, 0, 1, 2])
    cbar.ax.set_yticklabels([r"$0.01\,\%$", r"$0.1\,\%$", r"$1\,\%$",
                             r"$10\,\%$", r"$100\,\%$"])

    # Axis label
    fig.text(0.4, 0.05, "Inline Offset (km)", fontsize=14)
    fig.text(0.08, 0.6, "Crossline Offset (km)", rotation=90, fontsize=14)

    # Title
    fig.suptitle(title, y=1, fontsize=20)
    plt.show()


###############################################################################
def plot_lineplot_ex(x, y, data, epm_fs, grid):
    xi = x.size//2
    yi = y.size//2

    fn = sint.interp1d(x, data[:, xi], bounds_error=False)
    # x1 = fn(grid.nodes_x)

    fn = sint.interp1d(y, data[yi, :], bounds_error=False)
    y1 = fn(grid.nodes_x)

    plt.figure(figsize=(15, 8))

    plt.plot(y/1e3, np.abs(epm_fs[yi, :]), 'C1', lw=3, label='Inline empymod')
    plt.plot(y/1e3, np.abs(data[yi, :]), 'k:', label='Inline emg3d')
    plt.plot(grid.nodes_x/1e3, np.abs(y1), 'k*', label='Grid points emg3d')

    plt.yscale('log')
    plt.title(r'Inline $H_x$', fontsize=20)
    plt.xlabel('Offset (km)', fontsize=14)
    plt.ylabel(r'|Amplitude (A/m)|', fontsize=14)
    plt.legend()
    plt.show()


###############################################################################
# Full-space model for a loop dipole
# ----------------------------------
#
# empymod
# ```````

# Survey parameters
# x = (np.arange(1025))*5-2560  # <= Higher precision, but slower
x = (np.arange(256))*20-2550
rx = np.repeat([x, ], np.size(x), axis=0)
ry = rx.transpose()

# Model parameters
resh = 1.              # Horizontal resistivity
aniso = np.sqrt(2.)    # Anisotropy
resv = resh*aniso**2   # Vertical resistivity
src = [-0.5, 0.5, -0.3, 0.3, -300.5, -299.5]  # Source:[x1, x2, y1, y2, z1, z2]
src_c = np.mean(np.array(src).reshape(3, 2), 1).ravel()  # Center pts of source
zrec = -400.           # Receiver depth
freq = 0.77            # Frequency
strength = np.pi       # Source strength

# Input for empymod
inp = {
    'src': src,
    'depth': [],
    'res': resh,
    'aniso': aniso,
    'strength': strength,
    'freqtime': freq,
    'htarg': {'pts_per_dec': -1},
}

###############################################################################
# `empymod` uses by default a `LHS` with positive z down, emg3d a `RHS` with
# positive z up. We therefore switch the sign of the H-field.

rxx = rx.ravel()
ryy = ry.ravel()

# e-field
epm_fs_ex = empymod.loop(rec=[rxx, ryy, zrec, 0, 0], mrec=False, verb=3,
                         **inp).reshape(np.shape(rx))
epm_fs_ey = empymod.loop(rec=[rxx, ryy, zrec, 90, 0], mrec=False, verb=1,
                         **inp).reshape(np.shape(rx))

# h-field
epm_fs_hx = -empymod.loop(rec=[rxx, ryy, zrec, 0, 0], verb=1,
                          **inp).reshape(np.shape(rx))
epm_fs_hy = -empymod.loop(rec=[rxx, ryy, zrec, 90, 0], verb=1,
                          **inp).reshape(np.shape(rx))
epm_fs_hz = -empymod.loop(rec=[rxx, ryy, zrec, 0, 90], verb=1,
                          **inp).reshape(np.shape(rx))


###############################################################################
# emg3d
# `````
#
# We choose a coarse grid here, to speed up the computation. For a result
# of higher precision choose the finer gridding.

# Create stretched grid
grid = emg3d.construct_mesh(
    frequency=freq,
    properties=resh,
    center=src_c,
    domain=([-2500, 2500], [-2500, 2500], [-2900, 2100]),
    min_width_limits=40,  # Decrease for higher precision
    stretching=[1.045, 1.045],  # Decrease for higher precision
    lambda_from_center=True,
    lambda_factor=0.8,
)
grid

###############################################################################
# Create a magnetic source through an electric loop
# -------------------------------------------------
#
# ``emg3d.TxMagneticDipole`` creates an electric square loop perpendicular to
# the defined dipole, where the area of the square loop corresponds to the
# length of the dipole.

# Create a magnetic dipole source
source = emg3d.TxMagneticDipole(src, strength=strength)

# Get the model
model = emg3d.Model(grid, property_x=resh, property_z=resv,
                    mapping='Resistivity')

# Compute the electric field
efield = emg3d.solve_source(model, source, freq, verb=4, plain=True)


###############################################################################
# Compare the electric field generated from the magnetic source
# -------------------------------------------------------------
e3d_fs_ex = efield.get_receiver((rx, ry, zrec, 0, 0))
plot_result_rel(epm_fs_ex, e3d_fs_ex, x, r'Diffusive Fullspace $E_x$',
                vmin=-17, vmax=-10, mode='abs')

###############################################################################
e3d_fs_ey = efield.get_receiver((rx, ry, zrec, 90, 0))
plot_result_rel(epm_fs_ey, e3d_fs_ey, x, r'Diffusive Fullspace $E_y$',
                vmin=-17, vmax=-10, mode='abs')


###############################################################################
# Diffusive Fullspace :math:`E_z`
# -------------------------------
#
# The :math:`E_z`-field due to a z-directed magnetic source is zero.
#
# Compare the magnetic field generated from the magnetic source
# -------------------------------------------------------------
#
# Compute magnetic field :math:`H` from the electric field
# ````````````````````````````````````````````````````````

hfield = emg3d.get_magnetic_field(model, efield)

###############################################################################
# Plot
# ````
e3d_fs_hx = hfield.get_receiver((rx, ry, zrec, 0, 0))
plot_result_rel(epm_fs_hx, e3d_fs_hx, x, r'Diffusive Fullspace $H_x$',
                vmin=-13, vmax=-8, mode='abs')

###############################################################################

e3d_fs_hy = hfield.get_receiver((rx, ry, zrec, 90, 0))
plot_result_rel(epm_fs_hy, e3d_fs_hy, x, r'Diffusive Fullspace $H_y$',
                vmin=-13, vmax=-8, mode='abs')

###############################################################################

e3d_fs_hz = hfield.get_receiver((rx, ry, zrec, 0, 90))
plot_result_rel(epm_fs_hz, e3d_fs_hz, x, r'Diffusive Fullspace $H_z$',
                vmin=-13, vmax=-8, mode='abs')

###############################################################################
# The line-plot shows clearly the high error around the source, due to our
# coarse meshing. By choosing a finer mesh at the center we can reduce this
# error significantly, at the cost of computational time.

plot_lineplot_ex(x, x, e3d_fs_hx.real, epm_fs_hx.real, grid)

###############################################################################
emg3d.Report()
